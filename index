<!DOCTYPE html>
<html lang="en" class="h-full bg-zinc-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangent Matrix VTT</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    // Swapped gray for zinc for a mono-dark theme
                    colors: {
                        zinc: {
                            50: '#fafafa',
                            100: '#f4f4f5',
                            200: '#e4e4e7',
                            300: '#d4d4d8',
                            400: '#a1a1aa',
                            500: '#71717a',
                            600: '#52525b',
                            700: '#3f3f46',
                            800: '#27272a',
                            900: '#18181b',
                            950: '#09090b',
                        },
                    }
                },
            },
        }
    </script>
    <style>
        /* Basic styling for the canvas itself */
        #vtt-canvas {
            display: block;
            background-color: #3f3f46; /* bg-zinc-700 */
            border-radius: 0.5rem; /* rounded-lg */
            cursor: default;
        }

        /* Custom styling for the color input swatch */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            /* Make it a 40x40 square */
            width: 40px; 
            height: 40px;
            border: none;
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 0.375rem;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #52525b; /* border-zinc-600 */
            border-radius: 0.375rem;
        }
        input[type="color"]::-moz-color-swatch {
            border: 2px solid #52525b; /* border-zinc-600 */
            border-radius: 0.375rem;
        }

        /* Accordion Header Styles */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .collapsible-header svg {
            transition: transform 0.2s;
            flex-shrink: 0;
            color: #71717a; /* zinc-500 */
        }
        .collapsible-header.collapsed svg {
            transform: rotate(-90deg);
        }
    </style>
</head>
<body class="h-full font-sans text-zinc-200 overflow-hidden">

    <!-- Main Application Layout -->
    <div class="flex h-screen">

        <!-- Sidebar / "Console" -->
        <aside class="w-72 bg-zinc-800 shadow-xl p-4 overflow-y-auto space-y-6">
            <h1 class="text-2xl font-bold text-white">VTT Console</h1>

            <!-- Section: Map Layer -->
            <div class="space-y-2">
                <label for="map-upload" class="block text-sm font-medium text-zinc-300">Background Map Layer</label>
                <!-- Updated file input button style -->
                <input type="file" id="map-upload" accept="image/*" class="block w-full text-sm text-zinc-400
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-md file:border file:border-indigo-500
                    file:text-sm file:font-semibold
                    file:bg-transparent file:text-indigo-400
                    hover:file:bg-indigo-900/30
                    cursor-pointer
                ">
                <!-- Switched to red border button -->
                <button id="clear-map" class="w-full bg-transparent hover:bg-red-900/20 text-red-400 border border-red-500 py-2 px-4 rounded-md text-sm transition-colors">Clear Map</button>
            </div>

            <!-- Section: Grid Controls -->
            <div class="space-y-2 pt-4 border-t border-zinc-700">
                <h2 class="text-lg font-semibold text-white collapsible-header collapsed" id="grid-header">
                    <span>Grid Controls</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </h2>
                <div id="grid-content" class="collapsible-content space-y-3 hidden">
                    <div class="p-3 bg-zinc-700 rounded-lg space-y-3">
                        <label for="grid-type" class="block text-sm font-medium text-zinc-300">Grid Type</label>
                        <select id="grid-type" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm">
                            <option value="none">None</option>
                            <option value="graph">Graph (Square)</option>
                            <option value="hex" selected>Hex Grid (Pointy)</option>
                        </select>

                        <label for="grid-size" class="block text-sm font-medium text-zinc-300">Grid Size (px)</label>
                        <input type="number" id="grid-size" value="50" min="10" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm">
                        
                        <label for="grid-color" class="block text-sm font-medium text-zinc-300">Grid Color</label>
                        <input type="color" id="grid-color" value="#FFFFFF" class="w-full h-10 p-0">
                    </div>
                </div>
            </div>

            <!-- Section: Create Tools -->
            <div class="space-y-2 pt-4 border-t border-zinc-700">
                <h2 class="text-lg font-semibold text-white collapsible-header" id="create-header">
                    <span>Create</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </h2>
                <div id="create-content" class="collapsible-content space-y-4">
                    <!-- Add Token -->
                    <div class="p-3 bg-zinc-700 rounded-lg space-y-3">
                        <h3 class="font-medium">Add Token</h3>
                        <label for="token-name" class="sr-only">Token Name</label>
                        <input type="text" id="token-name" placeholder="Token Name" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm" value="New Token">
                        <label for="token-color" class="sr-only">Token Color</label>
                        <!-- Default value set to blue -->
                        <input type="color" id="token-color" value="#2563EB"> <!-- This is Tailwind's blue-600 -->
                        <!-- Updated button style -->
                        <button id="add-token" class="w-full bg-transparent hover:bg-pink-900/30 text-pink-400 border border-pink-500 py-2 px-4 rounded-md transition-colors">Add Token</button>
                    </div>
                    
                    <!-- Add Text -->
                    <div class="p-3 bg-zinc-700 rounded-lg space-y-3">
                        <h3 class="font-medium">Add Text</h3>
                        <label for="text-content" class="sr-only">Text Content</label>
                        <input type="text" id="text-content" placeholder="Text Label" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm" value="Hello!">
                        <!-- Updated button style -->
                        <button id="add-text" class="w-full bg-transparent hover:bg-blue-900/30 text-blue-400 border border-blue-500 py-2 px-4 rounded-md transition-colors">Add Text</button>
                    </div>
                </div>
            </div>

            <!-- Section: Tools -->
            <div class="space-y-2 pt-4 border-t border-zinc-700">
                <h2 class="text-lg font-semibold text-white collapsible-header collapsed" id="tools-header">
                    <span>Tools</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </h2>
                <div id="tools-content" class="collapsible-content space-y-4 hidden">
                    <!-- Dice Roller -->
                    <div class="p-3 bg-zinc-700 rounded-lg space-y-3">
                        <h3 class="font-medium">Dice Roller</h3>
                        <label for="dice-input" class="sr-only">Dice Notation</label>
                        <input type="text" id="dice-input" placeholder="e.g., 2d20kh1+5" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm" value="1d20">
                        <!-- Updated button style -->
                        <button id="roll-dice" class="w-full bg-transparent hover:bg-green-900/30 text-green-400 border border-green-500 py-2 px-4 rounded-md transition-colors">Roll Dice</button>
                        <div id="dice-result" class="text-center text-zinc-300 h-10 p-2 bg-zinc-800 rounded-md overflow-y-auto">
                            Roll Result
                        </div>
                    </div>
                </div>
            </div>

            <!-- Section: Selected Item Editor (Contextual) -->
            <div id="editor-panel" class="space-y-4 pt-4 border-t border-zinc-700 hidden">
                <h2 class="text-lg font-semibold text-white">Edit Selected Item</h2>

                <!-- Token Editor -->
                <div id="token-editor" class="p-3 bg-zinc-700 rounded-lg space-y-3 hidden">
                    <label for="token-name-edit" class="block text-sm font-medium text-zinc-300">Token Name</label>
                    <input type="text" id="token-name-edit" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm">
                    
                    <label for="token-color-edit" class="block text-sm font-medium text-zinc-300">Token Color</label>
                    <input type="color" id="token-color-edit" class="w-full">
                    
                    <!-- Switched to red border button -->
                    <button id="delete-token" class="w-full bg-transparent hover:bg-red-900/20 text-red-400 border border-red-500 py-2 px-4 rounded-md text-sm transition-colors">Delete Token</button>
                </div>

                <!-- Text Editor -->
                <div id="text-editor" class="p-3 bg-zinc-700 rounded-lg space-y-3 hidden">
                    <label for="text-content-edit" class="block text-sm font-medium text-zinc-300">Text Content</label>
                    <input type="text" id="text-content-edit" class="w-full bg-zinc-800 border border-zinc-600 rounded-md px-3 py-2 text-sm">
                    
                    <!-- Switched to red border button -->
                    <button id="delete-text" class="w-full bg-transparent hover:bg-red-900/20 text-red-400 border border-red-500 py-2 px-4 rounded-md text-sm transition-colors">Delete Text</button>
                </div>
            </div>

        </aside>

        <!-- Main Canvas Area -->
        <main class="flex-1 p-4" id="canvas-container">
            <canvas id="vtt-canvas"></canvas>
        </main>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('vtt-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');

            // --- STATE MANAGEMENT ---
            let mapImage = null;
            let tokens = []; // Token Layer
            let texts = [];  // Text Layer
            
            let selectedItem = null; // Can be a token or text object
            let isDragging = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            
            // View and Pan/Zoom state
            let view = { zoom: 1, offsetX: 0, offsetY: 0 };
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            let mapGrid = {}; // Holds the grid definition
            let baseHexSize = 50; // Default hex size

            // --- UI ELEMENTS ---
            const mapUpload = document.getElementById('map-upload');
            const clearMapButton = document.getElementById('clear-map');
            
            const addTokenButton = document.getElementById('add-token');
            const tokenNameInput = document.getElementById('token-name');
            const tokenColorInput = document.getElementById('token-color');
            
            const addTextButton = document.getElementById('add-text');
            const textContentInput = document.getElementById('text-content');

            const editorPanel = document.getElementById('editor-panel');
            
            const tokenEditor = document.getElementById('token-editor');
            const tokenNameEdit = document.getElementById('token-name-edit');
            const tokenColorEdit = document.getElementById('token-color-edit');
            const deleteTokenButton = document.getElementById('delete-token');
            
            const textEditor = document.getElementById('text-editor');
            const textContentEdit = document.getElementById('text-content-edit');
            const deleteTextButton = document.getElementById('delete-text');

            // Dice Roller UI
            const diceInput = document.getElementById('dice-input');
            const rollDiceButton = document.getElementById('roll-dice');
            const diceResult = document.getElementById('dice-result');

            // Grid UI
            const gridTypeSelect = document.getElementById('grid-type');
            const gridSizeInput = document.getElementById('grid-size');
            const gridColorInput = document.getElementById('grid-color');

            // Accordion UI
            const accordionHeaders = document.querySelectorAll('.collapsible-header');

            // --- CANVAS SETUP ---
            function resizeCanvas() {
                canvas.width = canvasContainer.clientWidth;
                canvas.height = canvasContainer.clientHeight;
                // Re-calculate the hex grid based on the new canvas size
                generateHexGridDefinition(canvas.width, canvas.height, baseHexSize);
                draw(); // Redraw everything on resize
            }

            // --- CORE RENDER FUNCTION ---
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // --- Apply Pan & Zoom ---
                ctx.save();
                ctx.translate(view.offsetX, view.offsetY);
                ctx.scale(view.zoom, view.zoom);

                // Layer 1: Background (Map)
                if (mapImage) {
                    // Draw map at 0,0 of the "world"
                    // Adjust size to cover the viewport roughly
                    const worldWidth = canvas.width / view.zoom;
                    const worldHeight = canvas.height / view.zoom;
                    ctx.drawImage(mapImage, 0, 0, worldWidth, worldHeight);
                }

                // Layer 2: Grid
                drawGrid();

                // Layer 3: Tokens
                tokens.forEach(token => {
                    // Draw the token circle
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, token.radius, 0, Math.PI * 2);
                    ctx.fillStyle = token.color;
                    ctx.fill();
                    ctx.strokeStyle = '#000000'; // Black border
                    ctx.lineWidth = 2 / view.zoom; // Scale line width
                    ctx.stroke();

                    // Draw the token name
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3 / view.zoom; // Scale line width
                    ctx.font = `${16 / view.zoom}px Inter`; // Scale font size
                    ctx.textAlign = 'center';
                    // Offset name below the token
                    ctx.strokeText(token.name, token.x, token.y + token.radius + (20 / view.zoom));
                    ctx.fillText(token.name, token.x, token.y + token.radius + (20 / view.zoom));
                });

                // Layer 4: Text
                texts.forEach(text => {
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 4 / view.zoom;
                    const fontSize = 24;
                    const scaledFont = `${fontSize / view.zoom}px Inter`; // Scale font size
                    ctx.font = scaledFont;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';

                    // Update text dimensions for hit detection (must use scaled font)
                    const metrics = ctx.measureText(text.content);
                    // We need the *unscaled* width/height for hit detection
                    text.width = metrics.width;
                    text.height = (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);

                    // Draw text with outline
                    ctx.strokeText(text.content, text.x, text.y);
                    ctx.fillText(text.content, text.x, text.y);
                });

                // Layer 5: Selection Highlight
                if (selectedItem) {
                    ctx.strokeStyle = '#FFFFFF'; // Bright white for mono theme
                    ctx.lineWidth = 3 / view.zoom;
                    ctx.setLineDash([10 / view.zoom, 5 / view.zoom]); // Scale dashes

                    if (selectedItem.type === 'token') {
                        const r = selectedItem.radius + (5 / view.zoom); // Padding
                        ctx.strokeRect(selectedItem.x - r, selectedItem.y - r, r * 2, r * 2);
                    } else if (selectedItem.type === 'text') {
                        const padding = 5 / view.zoom;
                        // Use the unscaled width/height for accurate bounding box
                        const font = `${24 / view.zoom}px Inter`;
                        ctx.font = font;
                        const metrics = ctx.measureText(selectedItem.content);
                        const w = metrics.width;
                        const h = (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);

                        ctx.strokeRect(
                            selectedItem.x - padding, 
                            selectedItem.y - padding, 
                            w + padding * 2, 
                            h + padding * 2
                        );
                    }
                    ctx.setLineDash([]); // Reset line dash
                }

                // --- Restore canvas from pan/zoom ---
                ctx.restore();
            }

            // --- GRID DRAWING LOGIC (Adapted from ttrpg-hex-map-maker.html) ---

            /**
             * Converts axial hex coordinates (q, r) to pixel coordinates (x, y).
             * @param {number} q - The q coordinate (column).
             * @param {number} r - The r coordinate (row).
             * @param {number} size - The side length of the hex.
             * @returns {{x: number, y: number}}
             */
            function hexToPixel(q, r, size) {
                const x = size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
                const y = size * (3 / 2 * r);
                return { x, y };
            }

            /**
             * Gets the pixel coordinates for a single corner of a hex.
             * @param {{x: number, y: number}} center - The center pixel coordinate of the hex.
             * @param {number} size - The side length of the hex.
             * @param {number} i - The corner index (0-5).
             * @returns {{x: number, y: number}}
             */
            function getHexCorner(center, size, i) {
                const angle_deg = 60 * i + 30; // 30 degrees for pointy top
                const angle_rad = Math.PI / 180 * angle_deg;
                return {
                    x: center.x + size * Math.cos(angle_rad),
                    y: center.y + size * Math.sin(angle_rad)
                };
            }
            
            /**
             * Draws a single hex outline at the given pixel coordinates.
             * @param {number} x - Center x-coordinate.
             * @param {number} y - Center y-coordinate.
             * @param {number} size - The side length of the hex.
             */
            function drawHexOutline(x, y, size) {
                // No ctx.beginPath() here, path is managed by drawGrid()
                for (let i = 0; i < 6; i++) {
                    const corner = getHexCorner({x, y}, size, i);
                    if (i === 0) {
                        ctx.moveTo(corner.x, corner.y);
                    } else {
                        ctx.lineTo(corner.x, corner.y);
                    }
                }
                ctx.closePath();
            }

            /**
             * Draws a tiling graph (square) grid.
             * @param {number} size - Square side length
             */
            function drawGraphGrid(size) {
                // Determine the visible world bounds
                const xStart = -view.offsetX / view.zoom;
                const yStart = -view.offsetY / view.zoom;
                const xEnd = (canvas.width - view.offsetX) / view.zoom;
                const yEnd = (canvas.height - view.offsetY) / view.zoom;

                // Find the first grid line in view
                const firstCol = Math.floor(xStart / size) * size;
                const firstRow = Math.floor(yStart / size) * size;

                ctx.beginPath();
                for (let x = firstCol; x <= xEnd; x += size) {
                    ctx.moveTo(x, yStart);
                    ctx.lineTo(x, yEnd);
                }
                for (let y = firstRow; y <= yEnd; y += size) {
                    ctx.moveTo(xStart, y);
                    ctx.lineTo(xEnd, y);
                }
                ctx.stroke();
            }

            /**
             * Generates the axial coordinates for a hex grid that fits the canvas.
             * This populates the `mapGrid` object.
             * @param {number} canvasWidth - The width of the canvas.
             * @param {number} canvasHeight - The height of the canvas.
             * @param {number} size - The side length of the hexes.
             */
            function generateHexGridDefinition(canvasWidth, canvasHeight, size) {
                mapGrid = {};
                if (size <= 0) return;

                // Calculate approximate number of hexes needed
                const hexWidth = Math.sqrt(3) * size;
                const hexHeight = 2 * size;
                
                // Estimate rows/cols with some buffer
                // This logic is for a "pointy-top" grid layout
                // We calculate rows/cols based on the *unzoomed* canvas size
                // The culling in drawGrid will handle what's actually visible
                const worldWidth = canvasWidth / view.zoom;
                const worldHeight = canvasHeight / view.zoom;

                const rows = Math.ceil(worldHeight / (hexHeight * 0.75)) + 2;
                const cols = Math.ceil(worldWidth / hexWidth) + 2;

                const startRow = -Math.floor(rows / 2);
                const endRow = Math.ceil(rows / 2);
                const startCol = -Math.floor(cols / 2);
                const endCol = Math.ceil(cols / 2);

                for (let r = startRow; r < endRow; r++) {
                    for (let q = startCol; q < endCol; q++) {
                         // FIX: Removed the faulty `if` statement.
                         // The grid definition should be complete.
                         // Culling will be handled in drawGrid().
                        mapGrid[`${q},${r}`] = true;
                    }
                }
            }
            
            /**
             * Main grid drawing function, called by draw()
             */
            function drawGrid() {
                const gridType = gridTypeSelect.value;
                const gridSize = parseInt(gridSizeInput.value);
                if (gridType === 'none' || isNaN(gridSize) || gridSize <= 0) {
                    return;
                }

                // Update hex size and regenerate grid if size changed
                if (gridType === 'hex' && baseHexSize !== gridSize) {
                    baseHexSize = gridSize;
                    // Regenerate grid definition based on current canvas size
                    generateHexGridDefinition(canvas.width, canvas.height, baseHexSize);
                }

                ctx.strokeStyle = gridColorInput.value;
                ctx.lineWidth = 1 / view.zoom; // Scale grid lines
                ctx.globalAlpha = 0.5; // Make grid semi-transparent

                if (gridType === 'graph') {
                    drawGraphGrid(gridSize);
                } else if (gridType === 'hex') {
                    // Determine visible world bounds
                    const xStart = -view.offsetX / view.zoom;
                    const yStart = -view.offsetY / view.zoom;
                    const xEnd = (canvas.width - view.offsetX) / view.zoom;
                    const yEnd = (canvas.height - view.offsetY) / view.zoom;
                    const buffer = baseHexSize * 2;

                    ctx.beginPath(); // Start one path for all hexes
                    for (const key in mapGrid) {
                        const [q, r] = key.split(',').map(Number);
                        const { x, y } = hexToPixel(q, r, baseHexSize);
                        
                        // Culling: Only draw hexes that are in the viewport
                        if (x >= xStart - buffer && x <= xEnd + buffer &&
                            y >= yStart - buffer && y <= yEnd + buffer) {
                            
                            // drawHexOutline now just adds to the path
                            for (let i = 0; i < 6; i++) {
                                const corner = getHexCorner({x, y}, baseHexSize, i);
                                if (i === 0) {
                                    ctx.moveTo(corner.x, corner.y);
                                } else {
                                    ctx.lineTo(corner.x, corner.y);
                                }
                            }
                            ctx.closePath();
                        }
                    }
                    ctx.stroke(); // Stroke the entire path at once
                }
                
                ctx.globalAlpha = 1.0; // Reset alpha
            }


            // --- UI EVENT HANDLERS ---

            // Accordion Listeners
            accordionHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    content.classList.toggle('hidden');
                    header.classList.toggle('collapsed');
                });
            });
            // Open the "Create" accordion by default
            document.getElementById('create-header').classList.remove('collapsed');
            document.getElementById('create-content').classList.remove('hidden');


            // Grid controls
            gridTypeSelect.addEventListener('change', draw);
            gridSizeInput.addEventListener('input', () => {
                // We need to re-generate and draw
                const gridSize = parseInt(gridSizeInput.value);
                if (!isNaN(gridSize) && gridSize > 0) {
                    if (gridTypeSelect.value === 'hex') {
                        baseHexSize = gridSize;
                        generateHexGridDefinition(canvas.width, canvas.height, baseHexSize);
                    }
                    draw();
                }
            });
            gridColorInput.addEventListener('input', draw);

            // Map
            mapUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        mapImage = new Image();
                        mapImage.onload = () => draw();
                        mapImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            clearMapButton.addEventListener('click', () => {
                mapImage = null;
                mapUpload.value = null; // Reset file input
                draw();
            });

            // Token
            addTokenButton.addEventListener('click', () => {
                // Add token to the center of the current view
                const worldX = (canvas.width / 2 - view.offsetX) / view.zoom;
                const worldY = (canvas.height / 2 - view.offsetY) / view.zoom;

                const newToken = {
                    id: Date.now(),
                    type: 'token',
                    x: worldX,
                    y: worldY,
                    radius: 30,
                    color: tokenColorInput.value,
                    name: tokenNameInput.value || 'Token'
                };
                tokens.push(newToken);
                draw();
            });

            // Text
            addTextButton.addEventListener('click', () => {
                // Add text to the center of the current view
                const worldX = (canvas.width / 2 - view.offsetX) / view.zoom;
                const worldY = (canvas.height / 2 - view.offsetY) / view.zoom;

                const newText = {
                    id: Date.now(),
                    type: 'text',
                    x: worldX,
                    y: worldY,
                    content: textContentInput.value || 'Text',
                    font: '24px Inter',
                    width: 0, // Will be calculated on draw
                    height: 0 // Will be calculated on draw
                };
                texts.push(newText);
                draw();
            });

            // --- EDITOR PANEL LOGIC ---

            function updateEditorUI() {
                if (!selectedItem) {
                    editorPanel.classList.add('hidden');
                    tokenEditor.classList.add('hidden');
                    textEditor.classList.add('hidden');
                    return;
                }

                editorPanel.classList.remove('hidden');

                if (selectedItem.type === 'token') {
                    // Show Token Editor
                    tokenEditor.classList.remove('hidden');
                    textEditor.classList.add('hidden');
                    
                    tokenNameEdit.value = selectedItem.name;
                    tokenColorEdit.value = selectedItem.color;
                } else if (selectedItem.type === 'text') {
                    // Show Text Editor
                    textEditor.classList.remove('hidden');
                    tokenEditor.classList.add('hidden');
                    
                    textContentEdit.value = selectedItem.content;
                }
            }

            // Token Editor Listeners
            tokenNameEdit.addEventListener('input', (e) => {
                if (selectedItem && selectedItem.type === 'token') {
                    selectedItem.name = e.target.value;
                    draw();
                }
            });

            tokenColorEdit.addEventListener('input', (e) => {
                if (selectedItem && selectedItem.type === 'token') {
                    selectedItem.color = e.target.value;
                    draw();
                }
            });

            deleteTokenButton.addEventListener('click', () => {
                if (selectedItem && selectedItem.type === 'token') {
                    tokens = tokens.filter(t => t.id !== selectedItem.id);
                    selectedItem = null;
                    updateEditorUI();
                    draw();
                }
            });

            // Text Editor Listeners
            textContentEdit.addEventListener('input', (e) => {
                if (selectedItem && selectedItem.type === 'text') {
                    selectedItem.content = e.target.value;
                    draw(); // Redraw to update text and its measured bounds
                }
            });

            deleteTextButton.addEventListener('click', () => {
                if (selectedItem && selectedItem.type === 'text') {
                    texts = texts.filter(t => t.id !== selectedItem.id);
                    selectedItem = null;
                    updateEditorUI();
                    draw();
                }
            });

            // Dice Roller Logic
            function parseDiceNotation(notation) {
                // Regex updated to handle 'kh' (keep highest) and 'kl' (keep lowest)
                const diceRegex = /(\d+)?d(\d+)(k[hl]\d+)?([+-]\d+)?/i;
                const match = notation.trim().match(diceRegex);

                if (!match) {
                    // Check for a simple number (modifier only)
                    const numMatch = notation.trim().match(/^[+-]?\d+$/);
                    if (numMatch) {
                        const modifier = parseInt(notation.trim());
                        return { total: modifier, rolls: [], modifier, resultString: `Total: ${modifier}` };
                    }
                    return { error: "Invalid notation" };
                }

                const numDice = match[1] ? parseInt(match[1]) : 1;
                const sides = parseInt(match[2]);
                const keep = match[3]; // e.g., "kh3" or "kl1"
                const modifier = match[4] ? parseInt(match[4]) : 0;

                if (sides === 0) return { error: "Cannot roll a d0" };
                if (numDice > 100) return { error: "Max 100 dice" }; // Safety limit

                let total = 0;
                let rolls = [];

                for (let i = 0; i < numDice; i++) {
                    const roll = Math.floor(Math.random() * sides) + 1;
                    rolls.push(roll);
                }

                let keptRolls = [...rolls];
                let droppedRolls = [];

                if (keep) {
                    const keepType = keep.substring(0, 2).toLowerCase(); // 'kh' or 'kl'
                    const numToKeep = parseInt(keep.substring(2));

                    if (numToKeep > numDice) {
                        return { error: "Cannot keep more dice than rolled" };
                    }

                    const sortedRolls = [...rolls].sort((a, b) => a - b);

                    if (keepType === 'kh') {
                        keptRolls = sortedRolls.slice(-numToKeep);
                        droppedRolls = sortedRolls.slice(0, numDice - numToKeep);
                    } else if (keepType === 'kl') {
                        keptRolls = sortedRolls.slice(0, numToKeep);
                        droppedRolls = sortedRolls.slice(numToKeep);
                    }
                }

                total = keptRolls.reduce((sum, roll) => sum + roll, 0);
                total += modifier;

                // --- Build Result String ---
                let resultString = `Total: ${total}`;
                
                // Show individual rolls
                if (numDice > 1) {
                    if (droppedRolls.length > 0) {
                        // Strike through dropped rolls
                        const allRollsStr = rolls.map(r => 
                            keptRolls.includes(r) ? r : `<s>${r}</s>`
                        ).join(', ');
                        resultString += ` (Rolls: [${allRollsStr}])`;
                    } else {
                        resultString += ` (Rolls: [${rolls.join(', ')}])`;
                    }
                }

                // Show modifier
                if (modifier !== 0) {
                    resultString += ` (Mod: ${modifier > 0 ? '+' : ''}${modifier})`;
                }
                
                return { total, rolls, keptRolls, droppedRolls, modifier, resultString };
            }

            rollDiceButton.addEventListener('click', () => {
                const notation = diceInput.value;
                const result = parseDiceNotation(notation);

                if (result.error) {
                    diceResult.textContent = result.error;
                    diceResult.classList.add('text-red-400');
                } else {
                    // Use innerHTML to render the <s> (strikethrough) tags
                    diceResult.innerHTML = result.resultString;
                    diceResult.classList.remove('text-red-400');
                }
            });

            // --- CANVAS MOUSE HANDLERS ---
            
            /**
             * Gets mouse position in world coordinates (accounts for pan/zoom)
             */
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                return {
                    x: (mouseX - view.offsetX) / view.zoom,
                    y: (mouseY - view.offsetY) / view.zoom
                };
            }

            function isMouseOverToken(token, x, y) {
                const dist = Math.hypot(x - token.x, y - token.y);
                return dist < token.radius;
            }

            function isMouseOverText(text, x, y) {
                // Use the text's calculated width/height
                // This requires text.width and text.height to be set in draw()
                const font = `${24 / view.zoom}px Inter`;
                ctx.font = font; // Must set context font to measure correctly
                const metrics = ctx.measureText(text.content);
                const w = metrics.width;
                const h = (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);

                return (
                    x >= text.x &&
                    x <= text.x + w &&
                    y >= text.y &&
                    y <= text.y + h
                );
            }
            
            // Prevent right-click menu
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            canvas.addEventListener('mousedown', (e) => {
                // Handle Panning
                if (e.button === 2) { // Right-click
                    isPanning = true;
                    panStart = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                    return;
                }

                // Handle Left-click (selection, dragging)
                if (e.button === 0) {
                    const { x, y } = getMousePos(e); // Get world coordinates
                    let clickedItem = null;

                    // Check for text click first (top layer)
                    for (let i = texts.length - 1; i >= 0; i--) {
                        if (isMouseOverText(texts[i], x, y)) {
                            clickedItem = texts[i];
                            break;
                        }
                    }

                    // If no text clicked, check for token
                    if (!clickedItem) {
                        for (let i = tokens.length - 1; i >= 0; i--) {
                            if (isMouseOverToken(tokens[i], x, y)) {
                                clickedItem = tokens[i];
                                break;
                            }
                        }
                    }

                    if (clickedItem) {
                        selectedItem = clickedItem;
                        isDragging = true;
                        dragOffsetX = x - selectedItem.x;
                        dragOffsetY = y - selectedItem.y;
                        canvas.style.cursor = 'move';
                    } else {
                        selectedItem = null;
                        canvas.style.cursor = 'default';
                    }
                    updateEditorUI();
                    draw();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                // Handle Panning
                if (isPanning) {
                    view.offsetX += e.clientX - panStart.x;
                    view.offsetY += e.clientY - panStart.y;
                    panStart = { x: e.clientX, y: e.clientY };
                    draw();
                    return;
                }

                // Handle Dragging
                if (isDragging && selectedItem) {
                    const { x, y } = getMousePos(e);
                    selectedItem.x = x - dragOffsetX;
                    selectedItem.y = y - dragOffsetY;
                    draw();
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 2) { // Right-click release
                    isPanning = false;
                    canvas.style.cursor = 'default';
                }
                if (e.button === 0) { // Left-click release
                    isDragging = false;
                    canvas.style.cursor = 'default';
                }
            });

            canvas.addEventListener('mouseout', () => {
                isPanning = false;
                isDragging = false; 
                canvas.style.cursor = 'default';
            });
            
            // Zoom listener
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate mouse position in world coordinates *before* zoom
                const worldX = (mouseX - view.offsetX) / view.zoom;
                const worldY = (mouseY - view.offsetY) / view.zoom;

                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                const newZoom = Math.max(0.1, Math.min(5, view.zoom * zoomFactor));

                // Adjust offsetX/offsetY to keep the mouse position fixed in world space
                view.offsetX = mouseX - worldX * newZoom;
                view.offsetY = mouseY - worldY * newZoom;
                view.zoom = newZoom;

                draw();
            }, { passive: false });


            // --- INITIALIZATION ---
            window.addEventListener('resize', resizeCanvas);
            
            // Initial generation of hex grid definition on load
            baseHexSize = parseInt(gridSizeInput.value);
            if (isNaN(baseHexSize)) baseHexSize = 50;
            generateHexGridDefinition(canvasContainer.clientWidth, canvasContainer.clientHeight, baseHexSize);
            
            resizeCanvas(); // Initial resize and draw
        });
    </script>
</body>
</html>
